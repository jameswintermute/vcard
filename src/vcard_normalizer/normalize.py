from __future__ import annotations

import re
import uuid as _uuid_mod

import vobject

from .model import Address, Card, NameComponents, Related, TypedValue

# ── UID normalisation ─────────────────────────────────────────────────────────

# Patterns that identify vendor-generated UIDs that should be replaced
_VENDOR_UID_PATTERNS = (
    re.compile(r"^proton-", re.I),
    re.compile(r"^proton_", re.I),
    re.compile(r"ab[0-9a-f]{8}-", re.I),          # Apple AddressBook: ABxxxx-
    re.compile(r"^X-APPLE", re.I),
    re.compile(r"@gmail\.com$", re.I),              # Google uses email as UID
    re.compile(r"@googlemail\.com$", re.I),
    re.compile(r"outlook\.", re.I),
    re.compile(r"live\.com", re.I),
    re.compile(r"apple\.com", re.I),
    re.compile(r"icloud\.com", re.I),
    re.compile(r"protonmail\.", re.I),
    re.compile(r"^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
               re.I),   # bare RFC urn:uuid — keep as-is (already canonical)
)

# The last pattern above is a *keep* pattern — we only replace if NOT matching it
_CANONICAL_UID = re.compile(
    r"^(urn:uuid:)?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
    re.I,
)
# vCard Studio-issued UIDs always start with this prefix
_VS_PREFIX = "vcard-studio-"


def _is_vendor_uid(uid: str) -> bool:
    """Return True if the UID looks like it was generated by a third-party vendor."""
    if not uid:
        return True
    # Already a clean vCard Studio UID — keep it
    if uid.startswith(_VS_PREFIX):
        return False
    # A bare RFC 4122 UUID with no vendor fingerprint — keep it
    if _CANONICAL_UID.match(uid):
        return False
    # Anything else (proton-web-xxx, apple ABxxx, google email UIDs, etc.) — replace
    return True


def new_vs_uid() -> str:
    """Generate a new vCard Studio UID: vcard-studio-<uuid4>"""
    return f"{_VS_PREFIX}{_uuid_mod.uuid4()}"


_PHOTO_PROPS = frozenset({"PHOTO", "LOGO", "SOUND"})


def _get_text(v, default=None):
    try:
        return str(v.value).strip()
    except Exception:
        return default


def _parse_addresses(vc: vobject.base.Component) -> list[Address]:
    addresses: list[Address] = []
    for adr in getattr(vc, "adr_list", []):
        try:
            val = adr.value
            addresses.append(
                Address(
                    po_box=val.box or None,
                    extended=val.extended or None,
                    street=val.street or None,
                    locality=val.city or None,
                    region=val.region or None,
                    postal_code=val.code or None,
                    country=val.country or None,
                )
            )
        except Exception:
            pass
    return addresses


def strip_photos(vc: vobject.base.Component) -> int:
    """Remove any PHOTO/LOGO/SOUND children from the raw vobject. Returns count removed."""
    to_remove = [
        child for child in list(vc.getChildren())
        if getattr(child, "name", "").upper() in _PHOTO_PROPS
    ]
    for child in to_remove:
        vc.remove(child)
    return len(to_remove)


def _get_type_param(prop) -> str:
    """Extract the TYPE parameter (HOME, WORK, CELL, etc.) from a vobject property.

    Returns empty string if no type is set.
    """
    try:
        tp = None
        if hasattr(prop, "type_param"):
            tp = prop.type_param
        elif hasattr(prop, "params"):
            tp = prop.params.get("TYPE", None)
        if tp is None:
            return ""
        if isinstance(tp, list):
            # vobject may return list — take first meaningful value
            for v in tp:
                s = str(v).upper().strip()
                if s and s not in ("INTERNET", "PREF", "X400"):
                    return s
            return ""
        s = str(tp).upper().strip()
        return s if s not in ("INTERNET", "PREF", "X400") else ""
    except Exception:
        return ""


def normalize_cards(
    vcards: list[tuple[vobject.base.Component, str]],
) -> list[Card]:
    """Convert (vobject_component, source_label) pairs into Card objects.

    Strips photos immediately and records the source filename on each card
    so the report can show where each contact came from.
    """
    out: list[Card] = []
    for vc, source_label in vcards:
        fn = _get_text(getattr(vc, "fn", None))

        # Parse structured N field into NameComponents
        name = NameComponents()
        if getattr(vc, "n", None):
            try:
                nval = vc.n.value
                # vobject gives us a Name object with attributes
                name.family     = (nval.family     or "").strip()
                name.given      = (nval.given      or "").strip()
                name.additional = (nval.additional or "").strip()
                name.prefix     = (nval.prefix     or "").strip()
                name.suffix     = (nval.suffix     or "").strip()
            except Exception:
                # Fallback: parse raw string
                raw = _get_text(getattr(vc, "n", None)) or ""
                if raw:
                    name = NameComponents.from_vcard_str(raw)

        emails: list[str] = []
        typed_emails: list[TypedValue] = []
        for e in getattr(vc, "email_list", []):
            val = _get_text(e)
            if val:
                val = val.lower()
                emails.append(val)
                # Extract TYPE parameter (HOME, WORK, etc.)
                etype = _get_type_param(e)
                typed_emails.append(TypedValue(value=val, type=etype))

        tels: list[str] = []
        typed_tels: list[TypedValue] = []
        for t in getattr(vc, "tel_list", []):
            val = re.sub(r"\s+", "", _get_text(t, ""))
            if val:
                tels.append(val)
                ttype = _get_type_param(t)
                typed_tels.append(TypedValue(value=val, type=ttype))

        org = None
        if getattr(vc, "org", None):
            try:
                org = " ".join([p for p in vc.org.value if p]).strip()
            except Exception:
                pass

        title = _get_text(getattr(vc, "title", None))
        bday = _get_text(getattr(vc, "bday", None))
        anniversary = _get_text(getattr(vc, "anniversary", None))
        uid = _get_text(getattr(vc, "uid", None))
        # Replace vendor-issued UIDs (proton-web-xxx, apple ABxxx, etc.)
        if _is_vendor_uid(uid or ""):
            old_uid = uid
            uid = new_vs_uid()
            if old_uid:
                pass  # logged below after card is created
        rev = _get_text(getattr(vc, "rev", None))
        addresses = _parse_addresses(vc)

        # Parse RELATED (vCard 4.0) — links to other contacts
        related: list[Related] = []
        for rel_prop in getattr(vc, "related_list", []):
            try:
                # type_param may be a string, a list, or absent depending on vobject version
                rel_type = "contact"
                tp = None
                if hasattr(rel_prop, "type_param"):
                    tp = rel_prop.type_param
                elif hasattr(rel_prop, "params"):
                    tp = rel_prop.params.get("TYPE", None)
                if tp is not None:
                    if isinstance(tp, list):
                        rel_type = str(tp[0]).lower().strip() if tp else "contact"
                    else:
                        rel_type = str(tp).lower().strip()
                val = str(rel_prop.value).strip()
                if val.startswith("urn:uuid:"):
                    related.append(Related(rel_type=rel_type, uid=val[9:]))
                elif val:
                    related.append(Related(rel_type=rel_type, text=val))
            except Exception:
                pass

        # Parse CATEGORIES — may be a list (vCard 4.0) or a comma-separated string
        categories: list[str] = []
        for cat_prop in getattr(vc, "categories_list", []):
            try:
                val = cat_prop.value
                if isinstance(val, (list, tuple)):
                    categories.extend(v.strip() for v in val if v.strip())
                elif isinstance(val, str):
                    categories.extend(v.strip() for v in val.split(",") if v.strip())
            except Exception:
                pass
        categories = sorted(set(categories))

        photo_count = strip_photos(vc)

        note = _get_text(getattr(vc, "note", None))

        # Parse X-VCARD-STUDIO-WAIVED — "not required" field markers
        # vobject stores X- properties with hyphens converted to underscores
        waived_raw = _get_text(getattr(vc, "x_vcard_studio_waived", None))
        waived: set = set()
        if waived_raw:
            waived = {f.strip() for f in waived_raw.split(",") if f.strip()}

        card = Card(
            raw=vc,
            fn=fn,
            name=name,
            emails=emails,
            tels=tels,
            typed_emails=typed_emails,
            typed_tels=typed_tels,
            org=org,
            title=title,
            bday=bday,
            anniversary=anniversary,
            uid=uid,
            rev=rev,
            addresses=addresses,
            categories=categories,
            related=related,
            note=note,
            _source_files=[source_label],
        )
        # Restore "not required" field markers (persisted as X-VCARD-STUDIO-WAIVED)
        if waived:
            card._waived = waived
        if photo_count:
            card.log_change(f"Stripped {photo_count} photo/logo/sound property(ies)")
        # Log UID replacement (old_uid set above if vendor UID was found)
        try:
            if old_uid:
                card.log_change(f"UID replaced: {old_uid} → {uid}")
        except NameError:
            pass

        out.append(card)
    return out


def strip_proprietary(card: Card) -> Card:
    from .proprietary import DefaultStripper
    return DefaultStripper().strip(card)
